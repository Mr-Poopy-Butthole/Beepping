<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bowling Physics Simulator</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header class="app-header">
    <h1>Bowling Physics Simulator</h1>
    <p class="subtitle">
      Adjust release parameters, lane conditions, and see the simulated ball path.
    </p>
  </header>

  <main class="layout">
    <!-- LEFT: CONTROL PANEL -->
    <section class="panel panel-controls">
      <h2>Inputs</h2>

      <div class="control-group">
        <h3>Release</h3>

        <label>
          Starting board at foul line
          <input id="startBoard" type="number" min="1" max="39" value="17" />
          <span class="hint">1 = bottom (right gutter), 39 = top (left gutter)</span>
        </label>

        <label>
          Launch angle (°)
          <input id="launchAngle" type="number" step="0.1" value="-1" />
          <span class="hint">Negative = toward right gutter (RH bowler)</span>
        </label>

        <label>
          Ball speed at foul line (mph)
          <input id="speedMph" type="number" step="0.1" value="16" />
        </label>

        <label>
          Rev rate (RPM)
          <input id="revRate" type="number" step="10" value="425" />
        </label>

        <label>
          Axis rotation (°)
          <input id="axisRotation" type="number" step="1" value="58" />
          <span class="hint">0 = end-over-end, 90 = full side roll</span>
        </label>

        <label>
          Axis tilt (°)
          <input id="axisTilt" type="number" step="1" value="15" />
          <span class="hint">0 = horizontal axis, 90 = vertical axis</span>
        </label>
      </div>

      <div class="control-group">
        <h3>Lane &amp; Oil</h3>

        <label>
          Oil distance (ft)
          <input id="oilDistance" type="number" step="1" value="40" />
        </label>

        <label>
          μ in oil (μ<sub>oil</sub>)
          <input id="muOil" type="number" step="0.01" value="0.04" />
        </label>

        <label>
          μ in dry (μ<sub>dry</sub>)
          <input id="muDry" type="number" step="0.01" value="0.20" />
        </label>
      </div>

      <div class="control-group">
        <h3>Ball</h3>
        <label>
          Radius (inches)
          <input id="ballRadiusIn" type="number" step="0.01" value="4.27" />
          <span class="hint">Approx. 8.5" diameter ball</span>
        </label>
      </div>

      <button id="simulateBtn" class="primary-btn">Simulate Shot</button>
    </section>

    <!-- RIGHT: LANE + PATH + OUTPUTS -->
    <section class="panel panel-visual">
      <div class="canvas-wrapper">
        <div class="lane-container">
          <!-- USBC-style SVG lane for a right-handed bowler (39 at top, 1 at bottom) -->
          <svg
            id="usbc-lane"
            viewBox="0 0 3200 400"
            preserveAspectRatio="xMidYMid meet"
          >
            <!-- Background -->
            <rect x="0" y="0" width="3200" height="400" fill="#3b2512" />

            <!-- Gutters -->
            <rect x="0" y="60" width="3200" height="80" fill="#181818" />
            <rect x="0" y="260" width="3200" height="80" fill="#181818" />

            <!-- Lane surface -->
            <rect
              id="lane-surface"
              x="0"
              y="80"
              width="3200"
              height="240"
              fill="#6b3f1f"
            />

            <!-- Foul line -->
            <rect x="40" y="80" width="10" height="240" fill="#f5f5f5" />

            <!-- Foul line dots on boards 35,30,25,20,15,10,5 (39 at top, 1 at bottom) -->
            <!-- y = 80 + (39 - board + 0.5)*(240/39) -->
            <g id="foul-dots">
              <circle cx="60" cy="107.7" r="6" fill="#f5f5f5" /> <!-- 35 -->
              <circle cx="60" cy="138.5" r="6" fill="#f5f5f5" /> <!-- 30 -->
              <circle cx="60" cy="169.2" r="6" fill="#f5f5f5" /> <!-- 25 -->
              <circle cx="60" cy="200.0" r="6" fill="#f5f5f5" /> <!-- 20 -->
              <circle cx="60" cy="230.8" r="6" fill="#f5f5f5" /> <!-- 15 -->
              <circle cx="60" cy="261.5" r="6" fill="#f5f5f5" /> <!-- 10 -->
              <circle cx="60" cy="292.3" r="6" fill="#f5f5f5" /> <!-- 5  -->
            </g>

            <!-- Pin deck (last part of lane) -->
            <rect
              id="pin-deck"
              x="2960"
              y="80"
              width="240"
              height="240"
              fill="#7b4a25"
            />

            <!-- Distance markers at 15, 30, 45, 60 feet -->
            <g id="distance-markers" font-family="Arial" font-size="16" fill="#f5f5f5">
              <!-- 15 ft -->
              <line x1="780" y1="80" x2="780" y2="320"
                    stroke="#ffffff" stroke-opacity="0.2" stroke-width="2" />
              <text x="780" y="70" text-anchor="middle">15 ft</text>

              <!-- 30 ft -->
              <line x1="1520" y1="80" x2="1520" y2="320"
                    stroke="#ffffff" stroke-opacity="0.2" stroke-width="2" />
              <text x="1520" y="70" text-anchor="middle">30 ft</text>

              <!-- 45 ft -->
              <line x1="2260" y1="80" x2="2260" y2="320"
                    stroke="#ffffff" stroke-opacity="0.2" stroke-width="2" />
              <text x="2260" y="70" text-anchor="middle">45 ft</text>

              <!-- 60 ft (headpin) -->
              <line x1="3000" y1="80" x2="3000" y2="320"
                    stroke="#ffffff" stroke-opacity="0.35" stroke-width="3" />
              <text x="3000" y="70" text-anchor="middle">60 ft</text>
            </g>

            <!-- Staggered arrows for right-handers: 6/9/11/14 ft -->
            <g id="arrows" fill="#f0d9b5">
              <!-- 6 ft: boards 35 & 5 -->
              <polygon points="336.0,107.7 306.0,99.7 306.0,115.7" />
              <polygon points="336.0,292.3 306.0,284.3 306.0,300.3" />
              <!-- 9 ft: boards 30 & 10 -->
              <polygon points="484.0,138.5 454.0,130.5 454.0,146.5" />
              <polygon points="484.0,261.5 454.0,253.5 454.0,269.5" />
              <!-- 11 ft: boards 25 & 15 -->
              <polygon points="582.7,169.2 552.7,161.2 552.7,177.2" />
              <polygon points="582.7,230.8 552.7,222.8 552.7,238.8" />
              <!-- 14 ft: board 20 -->
              <polygon points="730.7,200.0 700.7,192.0 700.7,208.0" />
            </g>

            <!-- Pin spots -->
            <g id="pin-spots" transform="translate(2950, 200)">
              <!-- Headpin (No.1) -->
              <circle cx="0" cy="0" r="10" fill="#f5f5f5" />

              <!-- Second row (2 & 3) -->
              <circle cx="30" cy="-20" r="10" fill="#f5f5f5" />
              <circle cx="30" cy="20" r="10" fill="#f5f5f5" />

              <!-- Third row (4,5,6) -->
              <circle cx="60" cy="-40" r="10" fill="#f5f5f5" />
              <circle cx="60" cy="0" r="10" fill="#f5f5f5" />
              <circle cx="60" cy="40" r="10" fill="#f5f5f5" />

              <!-- Back row (7,8,9,10) -->
              <circle cx="90" cy="-60" r="10" fill="#f5f5f5" />
              <circle cx="90" cy="-20" r="10" fill="#f5f5f5" />
              <circle cx="90" cy="20" r="10" fill="#f5f5f5" />
              <circle cx="90" cy="60" r="10" fill="#f5f5f5" />
            </g>
          </svg>

          <!-- Canvas overlay for ball path; same coordinate space as SVG (3200x400) -->
          <canvas id="pathCanvas" width="3200" height="400"></canvas>
        </div>
      </div>

      <div class="output">
        <h2>Outputs</h2>
        <div class="output-grid">
          <div>
            <span class="label">Entry board @ 60 ft:</span>
            <span id="entryBoard" class="value">–</span>
          </div>
          <div>
            <span class="label">Entry angle (°):</span>
            <span id="entryAngleOut" class="value">–</span>
          </div>
          <div>
            <span class="label">Impact speed (mph):</span>
            <span id="impactSpeedOut" class="value">–</span>
          </div>
        </div>
        <p class="hint small">
          These are physics outputs only. We can later connect them to a strike-probability model.
        </p>

        <!-- Ball axis visual -->
        <div class="ball-axis">
          <h2>Ball Axis at Release</h2>
          <canvas id="ballAxisCanvas" width="200" height="200"></canvas>
          <p class="hint small">
            View from behind the ball. Circle = ball, arrow = spin axis,
            dot = pin direction along that axis.
          </p>
        </div>
      </div>
    </section>
  </main>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const canvas = document.getElementById("pathCanvas");
      const ctx = canvas.getContext("2d");

      const ballAxisCanvas = document.getElementById("ballAxisCanvas");
      const ballAxisCtx = ballAxisCanvas.getContext("2d");

      // DOM references
      const startBoardInput   = document.getElementById("startBoard");
      const launchAngleInput  = document.getElementById("launchAngle");
      const speedMphInput     = document.getElementById("speedMph");
      const revRateInput      = document.getElementById("revRate");
      const axisRotationInput = document.getElementById("axisRotation");
      const axisTiltInput     = document.getElementById("axisTilt");
      const oilDistanceInput  = document.getElementById("oilDistance");
      const muOilInput        = document.getElementById("muOil");
      const muDryInput        = document.getElementById("muDry");
      const ballRadiusInInput = document.getElementById("ballRadiusIn");

      const simulateBtn       = document.getElementById("simulateBtn");

      const entryBoardOut     = document.getElementById("entryBoard");
      const entryAngleOut     = document.getElementById("entryAngleOut");
      const impactSpeedOut    = document.getElementById("impactSpeedOut");

      // Constants / geometry
      const LANE_LENGTH_FT = 60;   // down-lane
      const NUM_BOARDS     = 39;
      const BOARD_WIDTH_IN = 1.067; // standard board width
      const LANE_WIDTH_IN  = BOARD_WIDTH_IN * NUM_BOARDS;
      const G_FTPS2        = 32.174; // gravity in ft/s^2

      // SVG-based mapping constants
      const FOUL_X_PX      = 40;   // foul line x in SVG
      const HEADPIN_X_PX   = 3000; // 60 ft line in SVG
      const LANE_TOP_Y_PX  = 80;
      const LANE_HEIGHT_PX = 240;
      const BOARD_HEIGHT_PX = LANE_HEIGHT_PX / NUM_BOARDS; // pixels per board

      function mphToFps(mph) {
        return mph * 1.4666667;
      }

      function fpsToMph(fps) {
        return fps / 1.4666667;
      }

      function degToRad(deg) {
        return (deg * Math.PI) / 180;
      }

      // board <-> x_inch (center-based)
      // 1 = right gutter, 39 = left gutter, board 20 ≈ center
      function boardToXInches(board) {
        const zeroCentered = board - (NUM_BOARDS + 1) / 2; // board 20 ≈ 0
        return zeroCentered * BOARD_WIDTH_IN;
      }

      function xInchesToBoard(xInches) {
        return xInches / BOARD_WIDTH_IN + (NUM_BOARDS + 1) / 2;
      }

      // --- DRAW PATH ON TOP OF SVG ---

      function drawPath(ctx, path) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        if (!path || path.length === 0) return;

        ctx.strokeStyle = "#00ff88";
        ctx.lineWidth = 5;
        ctx.beginPath();

        for (let i = 0; i < path.length; i++) {
          const p = path[i];

          // Map down-lane distance y_ft -> SVG x coordinate
          const xPx =
            FOUL_X_PX +
            (p.y_ft / LANE_LENGTH_FT) * (HEADPIN_X_PX - FOUL_X_PX);

          // Map cross-lane x_in -> board -> SVG y coordinate
          const board = xInchesToBoard(p.x_in);  // 1 bottom/right .. 39 top/left

          const yPx =
            LANE_TOP_Y_PX +
            (NUM_BOARDS - board + 0.5) * BOARD_HEIGHT_PX;

          if (i === 0) {
            ctx.moveTo(xPx, yPx);
          } else {
            ctx.lineTo(xPx, yPx);
          }
        }

        ctx.stroke();

        // Draw final ball position
        const last = path[path.length - 1];
        const lastXPx =
          FOUL_X_PX +
          (last.y_ft / LANE_LENGTH_FT) * (HEADPIN_X_PX - FOUL_X_PX);
        const lastBoard = xInchesToBoard(last.x_in);
        const lastYPx =
          LANE_TOP_Y_PX +
          (NUM_BOARDS - lastBoard + 0.5) * BOARD_HEIGHT_PX;

        ctx.fillStyle = "#00ff88";
        ctx.beginPath();
        ctx.arc(lastXPx, lastYPx, 10, 0, Math.PI * 2);
        ctx.fill();
      }

      // --- BALL AXIS / PIN VISUAL ---

      function drawBallAxis(axisRotationDeg, axisTiltDeg) {
        const ctx2 = ballAxisCtx;
        if (!ctx2) return;

        const w = ctx2.canvas.width;
        const h = ctx2.canvas.height;
        ctx2.clearRect(0, 0, w, h);

        const cx = w / 2;
        const cy = h / 2;
        const radius = Math.min(w, h) * 0.4;

        // Ball circle
        ctx2.fillStyle = "#111";
        ctx2.beginPath();
        ctx2.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx2.fill();
        ctx2.strokeStyle = "#777";
        ctx2.lineWidth = 2;
        ctx2.stroke();

        // Direction of travel arrow (upward = down-lane)
        ctx2.strokeStyle = "#444";
        ctx2.lineWidth = 1.5;
        ctx2.beginPath();
        ctx2.moveTo(cx, cy + radius + 12);
        ctx2.lineTo(cx, cy - radius - 12);
        ctx2.stroke();
        ctx2.beginPath();
        ctx2.moveTo(cx, cy - radius - 12);
        ctx2.lineTo(cx - 5, cy - radius - 2);
        ctx2.lineTo(cx + 5, cy - radius - 2);
        ctx2.closePath();
        ctx2.fillStyle = "#444";
        ctx2.fill();

        // Compute axis unit vector (same as physics, with RH sign convention)
        const rotRad = degToRad(axisRotationDeg);
        const tiltRad = degToRad(axisTiltDeg);

        const a_z = Math.sin(tiltRad);
        const proj = Math.cos(tiltRad);
        // NOTE: negative sign so positive rotation hooks left for RH bowler
        const a_x = -Math.sin(rotRad) * proj;
        const a_y = Math.cos(rotRad) * proj;

        const len = Math.sqrt(a_x * a_x + a_y * a_y + a_z * a_z) || 1;
        const ax = a_x / len;
        const az = a_z / len;

        // Project to front view (looking from behind the ball): x horizontal, z vertical
        const scale = radius * 0.9;
        const sx = ax;
        const sz = az;

        const ex = cx + sx * scale;
        const ey = cy - sz * scale;

        // Spin axis line through center
        ctx2.strokeStyle = "#00ff88";
        ctx2.lineWidth = 2;
        ctx2.beginPath();
        ctx2.moveTo(cx - sx * scale, cy + sz * scale);
        ctx2.lineTo(ex, ey);
        ctx2.stroke();

        // Arrowhead
        ctx2.beginPath();
        const ahx1 = ex - sx * 8 - sz * 4;
        const ahy1 = ey + sz * 8 - sx * 4;
        const ahx2 = ex - sx * 8 + sz * 4;
        const ahy2 = ey + sz * 8 + sx * 4;
        ctx2.moveTo(ex, ey);
        ctx2.lineTo(ahx1, ahy1);
        ctx2.lineTo(ahx2, ahy2);
        ctx2.closePath();
        ctx2.fillStyle = "#00ff88";
        ctx2.fill();

        // Pin dot: along +axis direction on the surface
        const pinX = cx + sx * radius;
        const pinY = cy - sz * radius;
        ctx2.fillStyle = "#ffd54f";
        ctx2.beginPath();
        ctx2.arc(pinX, pinY, 4, 0, Math.PI * 2);
        ctx2.fill();
      }

      // --- PHYSICS SIMULATION (simplified Ji/Zhao-style) ---

      function simulateShot(params) {
        const {
          startBoard,
          launchAngleDeg,
          speedMph,
          revRateRpm,
          axisRotationDeg,
          axisTiltDeg,
          oilDistanceFt,
          muOil,
          muDry,
          ballRadiusIn,
        } = params;

        const R_ft = ballRadiusIn / 12; // inches -> ft
        const v0 = mphToFps(speedMph);  // ft/s

        // Launch angle: measured from straight downlane (+y).
        const angleRad = degToRad(launchAngleDeg);
        const vx0 = v0 * Math.sin(angleRad); // sideways
        const vy0 = v0 * Math.cos(angleRad); // downlane

        // Angular speed from rev rate
        const omegaMag = (2 * Math.PI * revRateRpm) / 60; // rad/s

        // Axis orientation from rotation & tilt
        const rotRad = degToRad(axisRotationDeg);
        const tiltRad = degToRad(axisTiltDeg);

        const a_z = Math.sin(tiltRad);
        const proj = Math.cos(tiltRad);
        // RH convention: negative sign so positive rotation hooks left
        const a_x = -Math.sin(rotRad) * proj;
        const a_y = Math.cos(rotRad) * proj;

        const len = Math.sqrt(a_x * a_x + a_y * a_y + a_z * a_z) || 1;
        const ax = a_x / len;
        const ay = a_y / len;
        const az = a_z / len;

        const omega_x0 = omegaMag * ax;
        const omega_y0 = omegaMag * ay;
        const omega_z0 = omegaMag * az;

        // Start position: at foul line, chosen board
        const x0_in = boardToXInches(startBoard);
        const y0_ft = 0;

        // Simple solid sphere inertia (assume m=1)
        const I = 0.4 * R_ft * R_ft;

        let x_in = x0_in;
        let y_ft = y0_ft;
        let vx = vx0;
        let vy = vy0;
        let wx = omega_x0;
        let wy = omega_y0;
        let wz = omega_z0;

        const dt = 0.005;
        const maxTime = 5;

        const path = [];
        let t = 0;

        while (t < maxTime && y_ft < LANE_LENGTH_FT) {
          const mu = y_ft < oilDistanceFt ? muOil : muDry;

          let x_ft = x_in / 12;

          // Slip velocity at contact point
          const vs_x = vx + R_ft * wy;
          const vs_y = vy - R_ft * wx;
          const vs = Math.sqrt(vs_x * vs_x + vs_y * vs_y) || 1e-6;

          // Friction acceleration (m=1)
          const ax_lin = -mu * G_FTPS2 * (vs_x / vs);
          const ay_lin = -mu * G_FTPS2 * (vs_y / vs);

          // Friction forces (same as accelerations with m=1)
          const Fx = ax_lin;
          const Fy = ay_lin;

          // Torques
          const tau_x = -R_ft * Fy;
          const tau_y = R_ft * Fx;

          const alpha_x = tau_x / I;
          const alpha_y = tau_y / I;

          // Integrate
          vx += ax_lin * dt;
          vy += ay_lin * dt;
          wx += alpha_x * dt;
          wy += alpha_y * dt;

          x_ft += vx * dt;
          y_ft += vy * dt;

          x_in = x_ft * 12;

          path.push({
            x_in,
            y_ft,
          });

          t += dt;

          const boardNow = xInchesToBoard(x_in);
          if (boardNow < 1 || boardNow > NUM_BOARDS) break;
        }

        const last = path[path.length - 1] || { x_in: x0_in, y_ft: y0_ft };
        const finalSpeed = Math.sqrt(vx * vx + vy * vy);
        const impactSpeedMph = fpsToMph(finalSpeed);

        const entryBoard = xInchesToBoard(last.x_in);
        const entryAngleRad = Math.atan2(vx, vy);
        const entryAngleDeg = (entryAngleRad * 180) / Math.PI;

        return {
          path,
          entryBoard,
          entryAngleDeg,
          impactSpeedMph,
        };
      }

      function runSimulation() {
        const params = {
          startBoard:       parseFloat(startBoardInput.value)   || 17,
          launchAngleDeg:   parseFloat(launchAngleInput.value)  || 0,
          speedMph:         parseFloat(speedMphInput.value)     || 16,
          revRateRpm:       parseFloat(revRateInput.value)      || 425,
          axisRotationDeg:  parseFloat(axisRotationInput.value) || 58,
          axisTiltDeg:      parseFloat(axisTiltInput.value)     || 15,
          oilDistanceFt:    parseFloat(oilDistanceInput.value)  || 40,
          muOil:            parseFloat(muOilInput.value)        || 0.04,
          muDry:            parseFloat(muDryInput.value)        || 0.2,
          ballRadiusIn:     parseFloat(ballRadiusInInput.value) || 4.27,
        };

        const result = simulateShot(params);
        const { path, entryBoard, entryAngleDeg, impactSpeedMph } = result;

        drawPath(ctx, path);
        drawBallAxis(params.axisRotationDeg, params.axisTiltDeg);

        if (path.length > 0) {
          entryBoardOut.textContent = entryBoard.toFixed(1);
          entryAngleOut.textContent = entryAngleDeg.toFixed(1);
          impactSpeedOut.textContent = impactSpeedMph.toFixed(1);
        } else {
          entryBoardOut.textContent = "–";
          entryAngleOut.textContent = "–";
          impactSpeedOut.textContent = "–";
        }
      }

      simulateBtn.addEventListener("click", runSimulation);

      // Run once on load so we see a nice default hook shot
      runSimulation();
    });
  </script>
</body>
</html>
